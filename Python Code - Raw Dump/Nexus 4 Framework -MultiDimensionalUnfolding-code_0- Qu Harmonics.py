## Method Class Modules

### `MultiDimensionalUnfolding` (Method 1)
**Role**: Unfolds data recursively across dimensions and time.
- Summation over exponential layers of $k$ (iteration) and $d$ (dimension) to build $U_{k,d}$:

**Formula**:
$$
U_{k,d} = \sum_{j=1}^{2^k} \sum_{l=1}^{2^d} U_{k-1,j,l}
$$

Ideal for expanding data structures (e.g. image, simulation, tensor fields) into high-dimensional recursive forms.

---

### `AsymmetricQuantumFolding` (Method 2)
**Role**: Applies localized asymmetry during recursive folding  
- Models recursive harmonic decay with local asymmetry:

**Formula**:

$$
F(Q)_{\text{asym}} = \sum_{i=1}^n (P_i, A_i) \cdot e^{-H \cdot F \cdot t} \cdot (1 + \varepsilon_i)
$$

Useful for modeling individual systems with unique distortions — like molecules, quantum states, or emotional inputs.

---

### `UnifiedFoldingUnfolding` (Method 3)
**Role**: Combines folded and unfolded recursion in a single transformation  
- Combines prior results of folding $F(Q)$ and unfolding $U_{k,d}$ into a single recursive formula:

**Formula**:
$$
U(Q)_{\text{unified}} = F(Q) \cdot e^{-H \cdot F \cdot t} \cdot U_{k,d}
$$

Applies well to simulations of quantum many-body systems or harmonized recursive systems that grow and compress in feedback.

---

### `NonLinearUnfolding` (Method 4)
**Role**: Applies non-linear transformation to recursive unfolding  
- Uses sigmoid, tanh, or ReLU to transform recursive values:

**Formula**:
$$
U_{k,\text{nonlin}} = \sum_{j=1}^{2^k} U_{k-1}(j) \cdot f(U_{k-1}(j))
$$

Modeling nonlinear growth, such as neural activations, population growth, or recursive sentiment mapping.

---

### `QuantumErrorCorrector` (Method 5)
**Role**: Applies harmonic correction during folding
- Self-correcting formula stabilizes folded output:

**Formula**:
$$
F(Q)_{\text{corr}} = F(Q) \cdot e^{-H \cdot F \cdot t} \cdot (1 + \varepsilon_{\text{corr}})
$$

Maintains harmonic alignment under noise or distortion — used in AI memory, signal tuning, or quantum error correction.

---

### `RecursiveCollapser` (Method 6)
**Role**: Collapses a recursive structure harmonically  
- Contracts the system toward harmonic convergence.

**Formula**:
$$
R(t) = R_0 \cdot e^{-H \cdot F \cdot t}
$$

Used to ensure symbolic recursion does not diverge indefinitely.

---

### `MirrorReconstructor` (Method 7)
**Role**: Reconstructs harmonic balance with mirrored state  
- Reflects data transformation across an equilibrium state.

**Formula**:
$$
M(Q) = F(Q) \cdot \left(1 - \frac{|Q - Q^*|}{Q + Q^*}\right)
$$

Useful for self-healing data structures and error correction across recursive time steps.

---

### `TimeLoopFeedback` (Method 8)
**Role**: Adds folded state back into unfolding process  
- Recursively influences future states based on prior harmonized feedback.

**Formula**:
$$
U_{k+1} = f(U_k) + \beta \cdot F(Q_k)
$$

Drives adaptive recursive systems that refine themselves dynamically.

---

### `StateToSymbol` (Method 9)
**Role**: Converts recursive state to symbolic expression or language  
- Maps harmonized structures into interpretable symbolic output.

**Formula**:
$$
S(t) = \Phi(U_{k,d}, H, F(Q)) \rightarrow \text{Tokens}
$$

Allows AI or recursive functions to communicate abstract states as meaningful information.

---

